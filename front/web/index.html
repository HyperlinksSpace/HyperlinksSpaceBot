<!DOCTYPE html>
<html lang="en">
<head>
  <base href="$FLUTTER_BASE_HREF">
  <!-- FAVICON: sourced from front/assets/favicon.ico (pubspec.yaml). Change that file and rebuild/deploy to update. -->
  <link rel="icon" type="image/x-icon" href="assets/assets/favicon.ico">
  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="Hyperlinks.Space App">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Hyperlinks.Space App">
  <meta
    name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover"
  >
  <style>
    body {
      background-color: #000000 !important;
      margin: 0;
      padding: 0;
      /* Prevent scroll animation when keyboard appears */
      scroll-behavior: auto !important;
      /* Prevent auto-scroll on mobile when keyboard appears */
      position: fixed;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    html {
      background-color: #000000 !important;
      /* Prevent scroll animation */
      scroll-behavior: auto !important;
      height: 100%;
      overflow: hidden;
    }
    /* Hide browser scrollbars on body/html only */
    body::-webkit-scrollbar,
    html::-webkit-scrollbar {
      display: none;
    }
    body {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    
    /* Sticky app styles to prevent swipe-down closure */
    .mobile-body {
      overflow: hidden !important;
      height: 100vh !important;
    }

    .mobile-wrap {
      position: absolute !important;
      left: 0 !important;
      top: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      overflow-x: hidden !important;
      overflow-y: auto !important;
    }

    .mobile-content {
      height: calc(100% + 1px) !important;
    }
    
    /* Hide Telegram close button and header controls */
    .tg-header,
    .tg-header *,
    [class*="tg-close"],
    [class*="close-button"],
    [data-role="close"],
    button[aria-label*="close" i],
    button[aria-label*="Close" i],
    .telegram-close-button,
    .tg-webapp-header button:last-child,
    .tg-header button,
    /* Target common Telegram header close button selectors */
    div[style*="close"] button,
    .header-close,
    .webapp-header-close {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      width: 0 !important;
      height: 0 !important;
      pointer-events: none !important;
    }
  </style>
  <!-- styles.css removed - not needed or create empty file if required -->
  <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
  <script src="https://unpkg.com/@tma.js/sdk@2.5.0/dist/index.iife.js"></script>
  <!-- Vercel Analytics -->
  <!-- Vercel automatically injects the analytics script in production -->
  <!-- If not injected, we'll try to load it manually -->
  <script>
    (function() {
      var analyticsLoaded = false;
      
      // Function to load Vercel Analytics script manually (if not auto-injected)
      function loadVercelAnalyticsScript() {
        if (analyticsLoaded || window.va) return;
        
        // Check if script already exists
        var existingScript = document.querySelector('script[src*="insights/script.js"]');
        if (existingScript) {
          console.log('Vercel Analytics script tag found, waiting for load...');
          return;
        }
        
        // Try to load the script manually
        var script = document.createElement('script');
        script.src = '/_vercel/insights/script.js';
        script.async = true;
        script.onload = function() {
          console.log('✓ Vercel Analytics script loaded manually');
          analyticsLoaded = true;
          setTimeout(setupVercelAnalytics, 100);
        };
        script.onerror = function() {
          console.warn('⚠ Could not load Vercel Analytics script (may not be enabled in Vercel)');
          // Don't retry - script doesn't exist
        };
        document.head.appendChild(script);
      }
      
      // Setup Vercel Analytics functions
      function setupVercelAnalytics() {
        // Check if va (Vercel Analytics) is available
        if (window.va) {
          console.log('✓ Vercel Analytics (va) detected:', typeof window.va, window.va);
          
          // Expose analytics functions globally for Dart interop
          window.vercelAnalytics = {
            track: function(name, options) {
              try {
                if (window.va && window.va.track) {
                  if (typeof name === 'string' && options) {
                    window.va.track(name, options);
                    console.log('✓ Vercel Analytics: Tracked event', name, options);
                  } else if (typeof name === 'object') {
                    window.va.track(name);
                    console.log('✓ Vercel Analytics: Tracked event object', name);
                  } else if (typeof name === 'string') {
                    window.va.track(name);
                    console.log('✓ Vercel Analytics: Tracked event', name);
                  }
                  return true;
                } else if (window.va && typeof window.va === 'function') {
                  // va is a function, call it
                  window.va();
                  console.log('✓ Vercel Analytics: Tracked via va()');
                  return true;
                }
              } catch (e) {
                console.error('Error tracking Vercel Analytics event:', e);
              }
              return false;
            },
            pageview: function() {
              try {
                if (window.va && typeof window.va === 'function') {
                  window.va();
                  console.log('✓ Vercel Analytics: Page view tracked via va()');
                } else if (window.va && window.va.track) {
                  window.va.track('pageview');
                  console.log('✓ Vercel Analytics: Page view tracked via va.track()');
                } else {
                  console.warn('⚠ Vercel Analytics: va object found but no track method');
                }
                return true;
              } catch (e) {
                console.error('Error tracking Vercel Analytics page view:', e);
              }
              return false;
            }
          };
          
          // Trigger initial page view
          if (window.vercelAnalytics.pageview) {
            window.vercelAnalytics.pageview();
          }
          
          console.log('✓ Vercel Analytics initialized and ready');
          return true;
        }
        return false;
      }
      
      // Try to setup immediately (in case Vercel already injected the script)
      if (!setupVercelAnalytics()) {
        // Wait a bit for Vercel to inject, then try manual load
        setTimeout(function() {
          if (!window.va) {
            console.log('Vercel Analytics not auto-injected, trying manual load...');
            loadVercelAnalyticsScript();
          }
        }, 1000);
        
        // Also retry setup periodically
        var attempts = 0;
        var maxAttempts = 20; // 10 seconds max
        var interval = setInterval(function() {
          attempts++;
          if (setupVercelAnalytics() || attempts >= maxAttempts) {
            clearInterval(interval);
            if (attempts >= maxAttempts && !window.va) {
              console.warn('⚠ Vercel Analytics not available after ' + maxAttempts + ' attempts');
              console.warn('⚠ Make sure Analytics is enabled in Vercel project settings');
              console.warn('⚠ Go to: Project Settings → Analytics → Enable Web Analytics');
            }
          }
        }, 500);
      }
    })();
  </script>
  <script>
    (function() {
      // Function to disable swipe-to-close
      function disableSwipeToClose() {
        // Method 1: Use Telegram WebApp API (available since v7.7)
        if (window.Telegram && window.Telegram.WebApp) {
          var webApp = window.Telegram.WebApp;
          
          // Call setupSwipeBehavior to disable vertical swipe
          if (typeof webApp.setupSwipeBehavior === 'function') {
            try {
              webApp.setupSwipeBehavior({
                allow_vertical_swipe: false
              });
              console.log('Swipe-to-close disabled via setupSwipeBehavior');
            } catch (e) {
              console.warn('Error calling setupSwipeBehavior:', e);
            }
          }
          
          // Fallback: Use postEvent
          if (webApp.postEvent) {
            try {
              webApp.postEvent('web_app_setup_swipe_behavior', {
                allow_vertical_swipe: false
              });
              console.log('Swipe-to-close disabled via postEvent');
            } catch (e) {
              console.warn('Error calling postEvent for swipe behavior:', e);
            }
          }
        }
        
        // Method 2: Use TMA.js SDK
        try {
          if (window.tmajs && window.tmajs.sdk) {
            var { postEvent } = window.tmajs.sdk;
            postEvent('web_app_setup_swipe_behavior', {
              allow_vertical_swipe: false
            });
            console.log('Swipe-to-close disabled via TMA.js SDK');
          }
        } catch (e) {
          console.warn('Error using TMA.js SDK:', e);
        }
      }
      
      // Function to hide Telegram close button
      function hideTelegramCloseButton() {
        // Hide close button using various selectors
        var selectors = [
          '.tg-header button:last-child',
          '.tg-header button',
          '[class*="close"]',
          '[data-role="close"]',
          'button[aria-label*="close" i]',
          '.telegram-close-button',
          '.header-close',
          '.webapp-header-close'
        ];
        
        selectors.forEach(function(selector) {
          try {
            var elements = document.querySelectorAll(selector);
            elements.forEach(function(el) {
              if (el && el.textContent && (el.textContent.trim() === '×' || el.textContent.trim() === '✕' || el.textContent.trim() === '✖' || el.textContent.includes('close'))) {
                el.style.display = 'none !important';
                el.style.visibility = 'hidden !important';
                el.style.opacity = '0 !important';
                el.style.width = '0 !important';
                el.style.height = '0 !important';
                el.style.pointerEvents = 'none !important';
              }
            });
          } catch (e) {
            // Ignore errors
          }
        });
        
        // Also hide entire header if it only contains close button
        try {
          var headers = document.querySelectorAll('.tg-header, [class*="header"]');
          headers.forEach(function(header) {
            var buttons = header.querySelectorAll('button');
            if (buttons.length === 1 && buttons[0].textContent && (buttons[0].textContent.trim() === '×' || buttons[0].textContent.trim() === '✕')) {
              header.style.display = 'none !important';
              header.style.visibility = 'hidden !important';
            }
          });
        } catch (e) {
          // Ignore errors
        }
      }
      
      // Prevent auto-scroll when keyboard appears on mobile
      function preventKeyboardScroll() {
        var lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
        var isKeyboardOpen = false;
        var originalScrollTop = 0;
        
        // Detect keyboard open/close by viewport height changes
        function handleResize() {
          var currentHeight = window.innerHeight;
          var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          
          if (isMobile) {
            // On mobile, keyboard reduces viewport height significantly
            // If viewport height decreased by more than 150px, keyboard is likely open
            var heightDiff = window.screen.height - currentHeight;
            if (heightDiff > 150) {
              if (!isKeyboardOpen) {
                isKeyboardOpen = true;
                originalScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                // Prevent scroll by locking position
                document.documentElement.style.overflow = 'hidden';
                document.body.style.overflow = 'hidden';
              }
            } else {
              if (isKeyboardOpen) {
                isKeyboardOpen = false;
                // Restore scroll
                document.documentElement.style.overflow = '';
                document.body.style.overflow = '';
              }
            }
          }
        }
        
        // Prevent scroll when keyboard is open
        function preventScroll(e) {
          if (isKeyboardOpen) {
            // Allow scrolling within input/textarea elements
            var target = e.target;
            if (target && (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.closest('input') || target.closest('textarea'))) {
              return true;
            }
            // Prevent page scroll
            window.scrollTo(0, originalScrollTop);
            return false;
          }
        }
        
        // Listen for resize (keyboard open/close triggers resize on mobile)
        window.addEventListener('resize', handleResize, { passive: true });
        
        // Prevent scroll events when keyboard is open
        window.addEventListener('scroll', function(e) {
          if (isKeyboardOpen) {
            window.scrollTo(0, originalScrollTop);
          }
        }, { passive: false });
        
        // Also prevent touchmove scroll when keyboard is open
        document.addEventListener('touchmove', preventScroll, { passive: false });
      }
      
      // Initialize on DOM ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          preventKeyboardScroll();
        });
      } else {
        preventKeyboardScroll();
      }
      
      // Initialize Telegram WebApp
      if (window.Telegram && window.Telegram.WebApp) {
        var webApp = window.Telegram.WebApp;
        webApp.ready();
        webApp.expand();
        
        // Hide close button immediately
        hideTelegramCloseButton();
        
        // Set header color to match background to hide it
        try {
          webApp.setHeaderColor('#000000');
        } catch (e) {
          console.warn('Error setting header color:', e);
        }
        
        // Disable swipe-to-close immediately
        disableSwipeToClose();
        
        // Also disable after a short delay to ensure WebApp is fully initialized
        setTimeout(function() {
          disableSwipeToClose();
          hideTelegramCloseButton();
        }, 100);
        
        setTimeout(function() {
          disableSwipeToClose();
          hideTelegramCloseButton();
        }, 500);
        
        // Keep hiding close button periodically in case it reappears
        setTimeout(function() {
          hideTelegramCloseButton();
        }, 1000);
        
        setTimeout(function() {
          hideTelegramCloseButton();
        }, 2000);
        
        // Also disable on viewport change (in case of fullscreen toggle)
        if (webApp.onEvent) {
          webApp.onEvent('viewportChanged', function() {
            setTimeout(function() {
              disableSwipeToClose();
              hideTelegramCloseButton();
            }, 100);
          });
        }
        
        // Use MutationObserver to hide close button when DOM changes
        if (window.MutationObserver) {
          var observer = new MutationObserver(function(mutations) {
            hideTelegramCloseButton();
          });
          observer.observe(document.body, {
            childList: true,
            subtree: true,
            attributes: false
          });
        }
      }
      
      // Also try to disable when TMA.js SDK is ready
      if (window.tmajs && window.tmajs.sdk) {
        setTimeout(function() {
          disableSwipeToClose();
        }, 200);
      }
      
      // Apply CSS sticky styles as additional protection
      // Only try this if we're actually in Telegram (not in browser)
      try {
        // Check if we're actually in Telegram by checking for valid launch params
        if (!window.tmajs || !window.tmajs.sdk) {
          throw new Error('TMA.js SDK not available');
        }
        
        var { retrieveLaunchParams, postEvent } = window.tmajs.sdk;
        var lp;
        
        try {
          lp = retrieveLaunchParams();
        } catch (e) {
          // If we can't retrieve launch params, we're probably in browser
          throw new Error('Unable to retrieve launch parameters - not in Telegram');
        }
        
        // Check if platform is valid (not 'unknown' which indicates browser)
        if (!lp || !lp.platform || lp.platform === 'unknown') {
          throw new Error('Invalid launch parameters - not in Telegram');
        }

        // Some versions of Telegram don't need the sticky classes
        if (!['macos', 'tdesktop', 'weba', 'web', 'webk'].includes(lp.platform)) {
          // Expand the application
          postEvent('web_app_expand');

          // Apply sticky classes to body
          document.body.classList.add('mobile-body');
          
          // Find Flutter's root elements and apply classes
          function applyFlutterStickyClasses() {
            var flutterWrap = document.querySelector('flt-glass-pane') || 
                            document.querySelector('flt-scene-host') ||
                            document.querySelector('flt-scene');
            
            var flutterContent = document.querySelector('flt-scene') ||
                                document.querySelector('flt-scene-host') ||
                                document.querySelector('flt-scene-host > flt-scene');
            
            if (flutterWrap) {
              flutterWrap.classList.add('mobile-wrap');
            }
            
            if (flutterContent) {
              flutterContent.classList.add('mobile-content');
            }
            
            return flutterWrap && flutterContent;
          }
          
          // Try to apply classes immediately
          if (!applyFlutterStickyClasses()) {
            var attempts = 0;
            var maxAttempts = 100;
            var interval = setInterval(function() {
              attempts++;
              if (applyFlutterStickyClasses() || attempts >= maxAttempts) {
                clearInterval(interval);
              }
            }, 100);
          }
        }
      } catch (e) {
        console.warn('Could not apply sticky app styles:', e);
      }
      
      // Prevent touchmove default to block swipe-down close gesture
      // Only prevent when swiping from the very top edge
      var touchStartY = 0;
      var touchStartTime = 0;
      
      document.addEventListener('touchstart', function(e) {
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }, { passive: true });
      
      document.addEventListener('touchmove', function(e) {
        // Only prevent if swiping down from the very top edge (first 20px)
        if (touchStartY < 20) {
          var touchY = e.touches[0].clientY;
          var deltaY = touchY - touchStartY;
          
          // If swiping down from top edge, prevent default to block close gesture
          if (deltaY > 5) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        }
      }, { passive: false });
      
      // Also prevent on body and html (only if body exists)
      if (document.body) {
        document.body.addEventListener('touchmove', function(e) {
          if (touchStartY < 20) {
            var touchY = e.touches[0].clientY;
            var deltaY = touchY - touchStartY;
            if (deltaY > 5) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
          }
        }, { passive: false });
      }
    })();
  </script>
</head>
<body style="background-color: #000000; margin: 0; padding: 0;">
  <script>
    // API key will be loaded at runtime from /api/config serverless function
    // This reads from Vercel's environment variables
    // Fallback for local development (can be set manually)
    window.APP_CONFIG = {
      API_KEY: '' // Will be fetched from serverless function at runtime
    };
    
    // Fallback if main.dart.js doesn't load
    window.addEventListener('error', function(e) {
      console.error('Error loading Flutter app:', e);
    });
  </script>
  <script src="main.dart.js" type="application/javascript"></script>
</body>
</html>


